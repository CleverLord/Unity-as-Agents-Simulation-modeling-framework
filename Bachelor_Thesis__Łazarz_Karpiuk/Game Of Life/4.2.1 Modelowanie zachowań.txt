# Akapit teoretyczny
Kiedy mamy doczynienia z agentami, mówimy o bytach w pewnym sensie inteligentnych, niezależnie czy za ich zachowaniem stoi jakiś skomplikowany system, czy jedna pętla warunkowa. Kiedy natomiast tworzymy takich agentów musimy mieć możliwość wprowadzenia do naszej symulacji tych zachowań.


4.2.1 Simple Game Of Life

Ta realizacja oparta jest o 3 klasy: GameManager, GameOfLifeCell, GridMap
Zaczynając od najprostrzej, GridMap to klasa, która posiada w sobie dwie główne zmienne oraz zmienną pomocniczą. Odpowiadają one kolejno za przechowywanie wymiarów mapy, przechowywanie wartości początkowej konkretnego pola w mapie, możliwośc zapisu mapy do pliku. Zmienna pomocnicza jest tam dlatego, że tablica dwuwymiarowa nie jest domyślnie serializowana, więc standardowym zabiegiem jest konwersja jej do jej płaskiego odpowiednika. Poza zmiennymi, jest jeszcze parę funkcji, ale to są tylko funkcje pomocnicze do konwersji i aktualizacji obiektu*. Ta klasa jest w praktyce jedynie strukturą, natomiast jest zadeklarowana jako klasa, żeby nie mieć ograniczeń typowej struktury. Najważniejszą z zalet jest możliwość dziedziczenia po klasie ScriptableObject, co dalej pozwala na zapisanie jej instancji jako pliku `.asset`. 
Następną klasą jest GameOfLifeCell. Jak nazwa wskazuje, reprezentuje ona pojedyńczą komórkę w naszej symulacji. Wie ona czy jest żywa, jaką ma pozycję i ma też referencje do sąsiadów. Dodatkowo ma wskazany jeden ze swoich komponentów, jako ten, który powinien się zmieniać w zależności od jej stanu, oraz posiada dwa materiały, które za jej wygląd odpowiadają. Wszystkie jej funkcje odpowiadają jedynie za aktualizację stanu podanego z zewnątrz. Warto zwrócić uwagę na to że klasa dziedziczy po MonoBehaviour, co sprawia, że jej instancja jest nie tylko czystymi danymi, ale funkcjonuje ona jako obiekt w świecie Unity. W kontekście naszej pracy, dziedziczenie po tej klasie klasyfikuje klasę jako agenta**.

*Opisać custom edytor Unity
**Opisać Monobehaviour**
Bazowo instancje tej klasy mają obiekt opisujący ich transformację w przestrzeni oraz są śledzone przez Unity (co zapobiega ich zniknięciu w skutek działania Garbage Collectora). Dodatkowo, takie instancje mogą posiadać 
Start Update LateUpdate OnTriggerEnter OnCollisionBegin

Najważniejszą klasą jest GameManager. To klasa która zawiera w sobie zaprogramowane zachowanie symulacji.
Kod rozpoczyna się od 5 zmiennych. 
*Place code snippet here*
- Pierwsza z nich jest referencją do definicji mapy. Jest w tym obiekcie zawarta informacja o wymiarach mapy i jej stanie początkowym*.
- Następna zmienna jest typu Vector2Int, czyli strukturą posiadającą dwie zmienne: x oraz y, z czego obie są liczbami całkowitymi. Ta zmienna określa wielkość mapy. Jest ona tak na prawdę lambdą, zwracająca pewne konkretne pole ze zmiennej powyżej. Zostało to tak zrobione, aby uniknąć długich odwołań do zmiennych w kodzie i jednocześnie zapobiedz potencjalnemu konfliktowi, w sytuacji jakby któreś pole przypadkowo zostało zmienione.
- Dalej jest tabela dwuwymiarowa z referencjami do obiektów komórek. 
- Na końcu jest takzwany prefab. To referencja do obiektu silnika, pozwalająca na instancjonowanie kopii ręcznie złożonego w edytorze modelu.

*Opisać Prefab
*Opisać podpinanie w inspektorze Unity

Następnie są dwie funkcje: Start oraz Update. 
Start wykonuje się raz, w momencie uruchomienia symulacji. Wewnątrz jest tylko funkcja pojawiająca komórki na scenie. Woła ona dwie podfunkcje.
Pierwsza z nich służy tylko do klonowania obiektów i inicjalizowania ich. Robi to poprzez 
- wyznaczenie puktu docelowego komórki, 
- wywołania funkcji Instantiate, która mówi Unity, że obiekt tworzony podlega pod ekosystem Unity. Jako parametry podajemy pozycję początkową, obrót początkowy, oraz referencję do swojego komponentu transform, dzięki czemu nowo utworzona komórka nie będzie elementem wrzuconym na scenę, a będzie podpięta jako dziecko pod obiekt Managera. 
- Następnie z nowo utworzonego obiektu pobieramy referencje do komponentu z naszym skryptem komórki. Wiemy że ten skrypt tam jest, ponieważ wcześniej zrobiliśmy nowy obiekt w Edytorze, dodaliśmy do niego ten komponent, zapisaliśmy ten obiekt jako asset, czyli jako plik projektowy, podlegający pod kontrolę wersji oddzielnie od sceny, i na końcu do instancji naszego Managera podpięliśmy referencję do nowo utworzonego assetu. 
- Mając referencję do naszego komponentu ustawiamy stan początkowy, zgodny z definicją mapy, i na końcu 
- zwracamy refrencję, do funkcji nadrzędnej, która ją zapisze.

Druga funkcja, w momencie kiedy wszystkie klony są już na scenie, wiąże odpowiednio ich referencje do siebie nawzajem.
W każdej iteracji silnika sprawdzane jest czy w danej klatce spacja została wciśnięta (nie mylić z "jest naciśnięta"), a następnie jeżeli tak, uruchamiane są dwie pętle. W pierwszej wyznaczany jest nowy stan komórek, w drugiej stan ten jest aplikowany, tzn. przenoszony z wewnętrzej dwuwymiarowej tablicy flag na obiekty na scenie, dzięki czemu możemy zaobserwować wynik działania algorytmu.